<!doctype html>

<head>
  <meta charset="UTF-8">
  <title>vaadin-menu-bar tests</title>
  <script src="../../web-component-tester/browser.js"></script>
  <script src="../../webcomponentsjs/webcomponents-lite.js"></script>
  <script src="../../iron-test-helpers/mock-interactions.js"></script>
  <link rel="import" href="../../test-fixture/test-fixture.html">
  <link rel="import" href="../../polymer/lib/utils/render-status.html">
  <link rel="import" href="../vaadin-menu-bar.html">
</head>

<body>
  <test-fixture id="default">
    <template>
      <vaadin-menu-bar></vaadin-menu-bar>
    </template>
  </test-fixture>

  <script>
    const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;

    function arrowUp(target) {
      MockInteractions.keyDownOn(target, 38, [], 'ArrowUp');
    }

    function arrowDown(target) {
      MockInteractions.keyDownOn(target, 40, [], 'ArrowDown');
    }

    function nextRender(target) {
      return new Promise(resolve => {
        Polymer.RenderStatus.afterNextRender(target, () => {
          resolve();
        });
      });
    }

    describe('sub-menu', () => {
      let menu, buttons, subMenu, item;

      const getButtons = menu => Array.from(menu.shadowRoot.querySelectorAll('vaadin-menu-bar-button'));

      beforeEach(done => {
        menu = fixture('default');
        menu.items = [
          {
            text: 'Menu Item 1',
            children: [
              {text: 'Menu Item 1 1'},
              {text: 'Menu Item 1 2'}
            ]
          },
          {text: 'Menu Item 2'},
          {
            text: 'Menu Item 3',
            children: [
              {text: 'Menu Item 3 1'},
              {text: 'Menu Item 3 2'}
            ]
          },
        ];
        subMenu = menu._subMenu;
        Polymer.RenderStatus.afterNextRender(menu, done);
      });

      afterEach(() => {
        if (subMenu && subMenu.opened) {
          subMenu.close();
        }
      });

      it('should open sub-menu when button with nested items clicked', async() => {
        buttons = getButtons(menu);
        buttons[0].click();
        await nextRender(subMenu);
        expect(subMenu.opened).to.be.true;
      });

      it('should not open sub-menu when button without nested items clicked', async() => {
        buttons = getButtons(menu);
        buttons[1].click();
        await nextRender(subMenu);
        expect(subMenu.opened).to.be.false;
      });

      it('should reopen sub-menu when different button with nested items clicked', async() => {
        buttons = getButtons(menu);
        buttons[0].click();
        await nextRender(subMenu);
        expect(subMenu.listenOn).to.equal(buttons[0]);
        const spy = sinon.spy(subMenu, 'close');
        buttons[2].click();
        await nextRender(subMenu);
        expect(subMenu.opened).to.be.true;
        expect(subMenu.listenOn).to.equal(buttons[2]);
        expect(spy).to.be.calledOnce;
      });

      (isIOS ? it.skip : it)('should open sub-menu on arrow down', async() => {
        buttons = getButtons(menu);
        arrowDown(buttons[0]);
        await nextRender(subMenu);
        expect(subMenu.opened).to.be.true;
      });

      (isIOS ? it.skip : it)('should close sub-menu on first item arrow up', async() => {
        buttons = getButtons(menu);
        arrowDown(buttons[0]);
        await nextRender(subMenu);

        item = subMenu.$.overlay.querySelector('vaadin-context-menu-item');
        arrowUp(item);
        await nextRender(subMenu);
        expect(subMenu.opened).to.be.false;
      });

      it('should close sub-menu on outside click', async() => {
        buttons = getButtons(menu);
        buttons[0].click();
        await nextRender(subMenu);

        document.body.click();
        await nextRender(subMenu);
        expect(subMenu.opened).to.be.false;
      });

      it('should close and dispatch item-selected event on select', async() => {
        buttons = getButtons(menu);
        buttons[0].click();
        await nextRender(subMenu);

        const spy = sinon.spy();
        menu.addEventListener('item-selected', spy);
        item = subMenu.$.overlay.querySelector('vaadin-context-menu-item');
        item.click();
        await nextRender(subMenu);
        expect(subMenu.opened).to.be.false;
        expect(spy).to.be.calledOnce;
        expect(spy.firstCall.args[0].detail.value).to.deep.equal({text: 'Menu Item 1 1'});
      });

      it('should dispatch item-selected event on leaf button click', () => {
        buttons = getButtons(menu);
        const spy = sinon.spy();
        menu.addEventListener('item-selected', spy);
        buttons[1].click();
        expect(spy).to.be.calledOnce;
        expect(spy.firstCall.args[0].detail.value).to.deep.equal({text: 'Menu Item 2'});
      });

      (isIOS ? it.skip : it)('should position bottom-aligned sub-menu to button top', async() => {
        menu.style.position = 'absolute';
        menu.style.bottom = '50px';
        buttons = getButtons(menu);
        buttons[0].click();
        await nextRender(subMenu);
        const overlayRect = subMenu.$.overlay.getBoundingClientRect();
        const buttonRect = buttons[0].getBoundingClientRect();
        expect(overlayRect.top + overlayRect.height).to.be.closeTo(buttonRect.top, 1);
      });

      it('should close sub-menu on items change', async() => {
        buttons = getButtons(menu);
        buttons[0].click();
        await nextRender(subMenu);

        menu.splice('items', 0, 1, {text: 'Menu Item 1'});
        await nextRender(subMenu);
        expect(subMenu.opened).to.be.false;
      });
    });
  </script>
</body>
