<!doctype html>

<head>
  <meta charset="UTF-8">
  <title>vaadin-menu-bar tests</title>
  <script src="../../web-component-tester/browser.js"></script>
  <script src="../../webcomponentsjs/webcomponents-lite.js"></script>
  <script src="../../iron-test-helpers/mock-interactions.js"></script>
  <script src="./helpers.js"></script>
  <link rel="import" href="../../test-fixture/test-fixture.html">
  <link rel="import" href="../../polymer/lib/utils/render-status.html">
  <link rel="import" href="not-animated-styles.html">
  <link rel="import" href="../vaadin-menu-bar.html">
</head>

<body>
  <test-fixture id="default">
    <template>
      <vaadin-menu-bar></vaadin-menu-bar>
    </template>
  </test-fixture>

  <script>
    const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;

    function nextRender(target) {
      return new Promise(resolve => {
        Polymer.RenderStatus.afterNextRender(target, () => {
          resolve();
        });
      });
    }

    describe('sub-menu', () => {
      let menu, buttons, subMenu, item;

      beforeEach(async() => {
        menu = fixture('default');
        menu.items = [
          {
            text: 'Menu Item 1',
            children: [
              {text: 'Menu Item 1 1'},
              {
                text: 'Menu Item 1 2',
                children: [
                  {text: 'Menu Item 1 2 1'}
                ]
              }
            ]
          },
          {text: 'Menu Item 2'},
          {
            text: 'Menu Item 3',
            children: [
              {text: 'Menu Item 3 1'},
              {text: 'Menu Item 3 2'}
            ]
          },
        ];
        await nextRender(menu);
        subMenu = menu._subMenu;
        buttons = menu._buttons;
      });

      afterEach(() => {
        if (subMenu && subMenu.opened) {
          subMenu.close();
        }
      });

      it('should open sub-menu when button with nested items clicked', async() => {
        buttons[0].click();
        await nextRender(subMenu);
        expect(subMenu.opened).to.be.true;
      });

      it('should not open sub-menu when button without nested items clicked', async() => {
        buttons[1].click();
        await nextRender(subMenu);
        expect(subMenu.opened).to.be.false;
      });

      it('should reopen sub-menu when different button with nested items clicked', async() => {
        buttons[0].click();
        await nextRender(subMenu);
        expect(subMenu.listenOn).to.equal(buttons[0]);
        const spy = sinon.spy(subMenu, 'close');
        buttons[2].click();
        await nextRender(subMenu);
        expect(subMenu.opened).to.be.true;
        expect(subMenu.listenOn).to.equal(buttons[2]);
        expect(spy).to.be.calledOnce;
      });

      (isIOS ? it.skip : it)('should open sub-menu on arrow down', async() => {
        const spy = sinon.spy();
        menu._container.addEventListener('keydown', spy);
        arrowDown(buttons[0]);
        await nextRender(subMenu);
        expect(subMenu.opened).to.be.true;
        expect(spy.firstCall.args[0].defaultPrevented).to.be.true;
      });

      (isIOS ? it.skip : it)('should open sub-menu and focus last item on arrow up', async() => {
        arrowUp(buttons[0]);
        await onceOpened(subMenu);
        expect(subMenu.opened).to.be.true;
        const items = subMenu.$.overlay.querySelectorAll('vaadin-context-menu-item');
        const last = items[items.length - 1];
        const spy = sinon.spy(last, 'focus');
        await nextRender(subMenu);
        expect(spy).to.be.calledOnce;
      });

      (isIOS ? it.skip : it)('should close sub-menu on first item arrow up', async() => {
        arrowDown(buttons[0]);
        await onceOpened(subMenu);
        item = subMenu.$.overlay.querySelector('vaadin-context-menu-item');
        expect(item).to.be.ok;
        await nextRender(subMenu);
        arrowUp(item);
        await nextRender(subMenu);
        expect(subMenu.opened).to.be.false;
      });

      (isIOS ? it.skip : it)('should switch menubar button with items and open submenu on arrow left', async() => {
        arrowDown(buttons[0]);
        await onceOpened(subMenu);
        expect(subMenu.opened).to.be.true;
        await nextRender(subMenu);
        const item = subMenu.$.overlay.querySelector('vaadin-context-menu-item');
        arrowLeft(item);
        await nextRender(subMenu);
        expect(subMenu.opened).to.be.true;
        expect(subMenu.listenOn).to.equal(buttons[2]);
      });

      (isIOS ? it.skip : it)('should switch menubar button without items and focus it on arrow left', async() => {
        arrowDown(buttons[2]);
        await onceOpened(subMenu);
        expect(subMenu.opened).to.be.true;
        await nextRender(subMenu);
        const item = subMenu.$.overlay.querySelector('vaadin-context-menu-item');
        arrowLeft(item);
        await nextRender(subMenu);
        expect(subMenu.opened).to.be.false;
        expect(buttons[1].hasAttribute('focused')).to.be.true;
        expect(buttons[1].hasAttribute('focus-ring')).to.be.true;
      });

      (isIOS ? it.skip : it)('should switch menubar button with items and open submenu on arrow right', async() => {
        arrowDown(buttons[2]);
        await onceOpened(subMenu);
        expect(subMenu.opened).to.be.true;
        await nextRender(subMenu);
        const item = subMenu.$.overlay.querySelector('vaadin-context-menu-item');
        arrowRight(item);
        await nextRender(subMenu);
        expect(subMenu.opened).to.be.true;
        expect(subMenu.listenOn).to.equal(buttons[0]);
      });

      (isIOS ? it.skip : it)('should switch menubar button without items and focus it on arrow right', async() => {
        arrowDown(buttons[0]);
        await onceOpened(subMenu);
        expect(subMenu.opened).to.be.true;
        await nextRender(subMenu);
        const item = subMenu.$.overlay.querySelector('vaadin-context-menu-item');
        arrowRight(item);
        await nextRender(subMenu);
        expect(subMenu.opened).to.be.false;
        expect(buttons[1].hasAttribute('focused')).to.be.true;
        expect(buttons[1].hasAttribute('focus-ring')).to.be.true;
      });

      (isIOS ? it.skip : it)('should focus first item on arrow down after opened on arrow left', async() => {
        arrowDown(buttons[0]);
        await onceOpened(subMenu);
        expect(subMenu.opened).to.be.true;
        let item = subMenu.$.overlay.querySelector('vaadin-context-menu-item');
        await nextRender(subMenu);
        arrowLeft(item);
        await nextRender(subMenu);
        item = subMenu.$.overlay.querySelector('vaadin-context-menu-item');
        const spy = sinon.spy(item, 'focus');
        arrowDown(buttons[2]);
        expect(spy).to.be.calledOnce;
      });

      (isIOS ? it.skip : it)('should focus last item on arrow down after opened on arrow left', async() => {
        arrowDown(buttons[0]);
        await onceOpened(subMenu);
        expect(subMenu.opened).to.be.true;
        const item = subMenu.$.overlay.querySelector('vaadin-context-menu-item');
        await nextRender(subMenu);
        arrowLeft(item);
        await nextRender(subMenu);
        const items = subMenu.$.overlay.querySelectorAll('vaadin-context-menu-item');
        const last = items[items.length - 1];
        const spy = sinon.spy(last, 'focus');
        arrowUp(buttons[2]);
        expect(spy).to.be.calledOnce;
      });

      (isIOS ? it.skip : it)('should switch submenu again on subsequent arrow left', async() => {
        menu.items[1] = {text: 'Menu Item 2', children: [{text: 'Menu Item 2 1'}]},
        menu.render();
        buttons = menu._buttons;
        await nextRender(menu);
        arrowDown(buttons[0]);
        await nextRender(subMenu);
        const item = subMenu.$.overlay.querySelector('vaadin-context-menu-item');
        arrowLeft(item);
        await nextRender(subMenu);
        arrowLeft(buttons[2]);
        await nextRender(subMenu);
        expect(subMenu.opened).to.be.true;
        expect(subMenu.listenOn).to.equal(buttons[1]);
        expect(buttons[1].hasAttribute('focused')).to.be.true;
      });

      (isIOS ? it.skip : it)('should close submenu on Esc after switch on arrow left', async() => {
        arrowDown(buttons[0]);
        await onceOpened(subMenu);
        expect(subMenu.opened).to.be.true;
        await nextRender(subMenu);
        const item = subMenu.$.overlay.querySelector('vaadin-context-menu-item');
        arrowLeft(item);
        await nextRender(subMenu);
        esc(buttons[2]);
        await nextRender(subMenu);
        expect(subMenu.opened).to.be.false;
        expect(buttons[2].hasAttribute('focused')).to.be.true;
      });

      it('should close sub-menu on outside click', async() => {
        buttons[0].click();
        await nextRender(subMenu);

        document.body.click();
        await nextRender(subMenu);
        expect(subMenu.opened).to.be.false;
      });

      it('should close and dispatch item-selected event on select', async() => {
        buttons[0].click();
        await nextRender(subMenu);

        const spy = sinon.spy();
        menu.addEventListener('item-selected', spy);
        item = subMenu.$.overlay.querySelector('vaadin-context-menu-item');
        item.click();
        await nextRender(subMenu);
        expect(subMenu.opened).to.be.false;
        expect(spy).to.be.calledOnce;
        expect(spy.firstCall.args[0].detail.value).to.deep.equal({text: 'Menu Item 1 1'});
      });

      (isIOS ? it.skip : it)('should not close on parent item click', async() => {
        arrowUp(buttons[0]);
        await onceOpened(subMenu);
        const items = subMenu.$.overlay.querySelectorAll('vaadin-context-menu-item');
        const last = items[items.length - 1];
        await nextRender(subMenu);
        last.click();
        await nextRender(subMenu);
        expect(subMenu.opened).to.be.true;
      });

      it('should dispatch item-selected event on leaf button click', () => {
        const spy = sinon.spy();
        menu.addEventListener('item-selected', spy);
        buttons[1].click();
        expect(spy).to.be.calledOnce;
        expect(spy.firstCall.args[0].detail.value).to.deep.equal({text: 'Menu Item 2'});
      });

      (isIOS ? it.skip : it)('should position bottom-aligned sub-menu to button top', async() => {
        menu.style.position = 'absolute';
        menu.style.bottom = '50px';
        buttons[0].click();
        await nextRender(subMenu);
        const overlayRect = subMenu.$.overlay.getBoundingClientRect();
        const buttonRect = buttons[0].getBoundingClientRect();
        expect(overlayRect.top + overlayRect.height).to.be.closeTo(buttonRect.top, 1);
      });

      (isIOS ? it.skip : it)('should position right-aligned sub-menu to button right', async() => {
        document.body.style.position = 'relative';
        document.body.style.width = '450px';
        document.body.style.minWidth = '450px';
        menu.style.position = 'absolute';
        menu.style.right = '0px';
        buttons[2].click();
        await nextRender(subMenu);
        const overlayRect = subMenu.$.overlay.getBoundingClientRect();
        const buttonRect = buttons[2].getBoundingClientRect();
        expect(overlayRect.right).to.be.closeTo(buttonRect.right, 1);
        document.body.style.position = '';
        document.body.style.width = '';
        document.body.style.minWidth = '';
      });

      it('should close sub-menu on items change', async() => {
        buttons[0].click();
        await nextRender(subMenu);

        menu.splice('items', 0, 1, {text: 'Menu Item 1'});
        await nextRender(subMenu);
        expect(subMenu.opened).to.be.false;
      });

      describe('expanded attribute', () => {
        it('should toggle expanded attribute on button with nested items clicked', async() => {
          buttons[0].click();
          await nextRender(subMenu);
          expect(buttons[0].hasAttribute('expanded')).to.be.true;

          buttons[0].click();
          expect(buttons[0].hasAttribute('expanded')).to.be.false;
        });

        it('should toggle expanded attribute on button with nested items toggled with the keyboard', async() => {
          arrowDown(buttons[0]);
          await nextRender(subMenu);
          expect(buttons[0].hasAttribute('expanded')).to.be.true;

          item = subMenu.$.overlay.querySelector('vaadin-context-menu-item');
          arrowUp(item);
          await nextRender(subMenu);
          expect(buttons[0].hasAttribute('expanded')).to.be.false;
        });

        it('should remove expanded attribute and restore focus when sub-menu closed on Esc', async() => {
          arrowDown(buttons[0]);
          await nextRender(subMenu);
          expect(buttons[0].hasAttribute('expanded')).to.be.true;

          MockInteractions.pressAndReleaseKeyOn(subMenu.$.overlay, 27, [], 'Escape');
          await nextRender(subMenu);
          expect(buttons[0].hasAttribute('expanded')).to.be.false;
          expect(buttons[0].hasAttribute('focus-ring')).to.be.true;
        });
      });
    });

    describe('open on hover', () => {
      let menu, buttons, subMenu;

      beforeEach(async() => {
        menu = fixture('default');
        menu.items = [
          {
            text: 'Menu Item 1',
            children: [
              {text: 'Menu Item 1 1'},
              {text: 'Menu Item 1 2'}
            ]
          },
          {text: 'Menu Item 2'},
          {
            text: 'Menu Item 3',
            children: [
              {text: 'Menu Item 3 1'},
              {text: 'Menu Item 3 2'}
            ]
          },
        ];
        menu.openOnHover = true;
        await nextRender(menu);
        subMenu = menu._subMenu;
        buttons = menu._buttons;
      });

      afterEach(() => {
        if (subMenu && subMenu.opened) {
          subMenu.close();
        }
      });

      it('should open sub-menu on mouseover on button with nested items', async() => {
        buttons[0].dispatchEvent(new CustomEvent('mouseover', {bubbles: true, composed: true}));
        await nextRender(subMenu);
        expect(subMenu.opened).to.be.true;
        expect(subMenu.listenOn).to.equal(buttons[0]);
      });

      it('should close open sub-menu on mouseover on button without nested items', async() => {
        buttons[0].dispatchEvent(new CustomEvent('mouseover', {bubbles: true, composed: true}));
        await nextRender(subMenu);
        buttons[1].dispatchEvent(new CustomEvent('mouseover', {bubbles: true, composed: true}));
        await nextRender(subMenu);
        expect(subMenu.opened).to.be.false;
      });

      it('should switch opened sub-menu on hover also when open-on-hover is false', async() => {
        menu.openOnHover = false;
        buttons[0].click();
        await nextRender(subMenu);
        buttons[2].dispatchEvent(new CustomEvent('mouseover', {bubbles: true, composed: true}));
        await nextRender(subMenu);
        expect(subMenu.opened).to.be.true;
        expect(subMenu.listenOn).to.equal(buttons[2]);
      });
    });
  </script>
</body>
