<!doctype html>

<head>
  <meta charset="UTF-8">
  <title>vaadin-menu-bar tests</title>
  <script src="../../web-component-tester/browser.js"></script>
  <script src="../../webcomponentsjs/webcomponents-lite.js"></script>
  <script src="../../iron-test-helpers/mock-interactions.js"></script>
  <link rel="import" href="../../test-fixture/test-fixture.html">
  <link rel="import" href="../../polymer/lib/utils/render-status.html">
  <link rel="import" href="../vaadin-menu-bar.html">
</head>

<body>
  <test-fixture id="default">
    <template>
      <vaadin-menu-bar></vaadin-menu-bar>
    </template>
  </test-fixture>

  <script>
    function arrowRight(target) {
      MockInteractions.keyDownOn(target, 39, [], 'ArrowRight');
    }

    function arrowLeft(target) {
      MockInteractions.keyDownOn(target, 37, [], 'ArrowLeft');
    }

    function home(target) {
      MockInteractions.keyDownOn(target, 36, [], 'Home');
    }

    function end(target) {
      MockInteractions.keyDownOn(target, 35, [], 'End');
    }


    describe('custom element definition', () => {
      let menu;

      beforeEach(() => {
        menu = fixture('default');
      });

      it('should be defined with correct tag name', () => {
        expect(customElements.get('vaadin-menu-bar')).to.be.ok;
      });

      it('should not expose class name globally', () => {
        expect(window.MenuBarElement).not.to.be.ok;
      });

      it('should have a valid version number', () => {
        expect(menu.constructor.version).to.match(/^(\d+\.)?(\d+\.)?(\d+)(-(alpha|beta)\d+)?$/);
      });
    });

    describe('root menu layout', () => {
      let menu, buttons;

      beforeEach(done => {
        menu = fixture('default');
        menu.items = [
          {text: 'Item 1'},
          {text: 'Item 2'},
          {text: 'Item 3', disabled: true},
          {text: 'Item 4'},
        ];
        Polymer.RenderStatus.afterNextRender(menu, () => {
          buttons = menu._buttons;
          done();
        });
      });

      it('should render button for each item, plus ellipsis button', () => {
        expect(buttons.length).to.equal(menu.items.length + 1);
      });

      it('should make the ellipsis button hidden by default', () => {
        const ellipsis = buttons[menu.items.length];
        expect(ellipsis.getAttribute('part')).to.equal('ellipsis-button');
        expect(ellipsis.hasAttribute('hidden')).to.be.true;
      });

      it('should set buttons text content based on the text property', () => {
        menu.items.forEach((item, idx) => {
          expect(buttons[idx].textContent.trim()).to.equal(item.text);
        });
      });

      it('should render disabled button if disabled property is true', () => {
        expect(buttons[2].disabled).to.be.true;
      });

      it('should set tabindex to -1 to all the buttons except first one', () => {
        menu.dispatchEvent(new CustomEvent('focusin', {bubbles: true, composed: true}));
        expect(buttons[0].getAttribute('tabindex')).to.equal('0');
        buttons.slice(1).forEach(btn => {
          expect(btn.focusElement.getAttribute('tabindex')).to.equal('-1');
        });
      });

      it('should move focus to next button on "arrow-right" keydown', () => {
        buttons[0].focus();
        const spy = sinon.spy(buttons[1], 'focus');
        arrowRight(buttons[0]);
        expect(spy).to.be.calledOnce;
        expect(buttons[1].hasAttribute('focused')).to.be.true;
      });

      it('should move focus to prev button on "arrow-left" keydown', () => {
        buttons[1].focus();
        const spy = sinon.spy(buttons[0], 'focus');
        arrowLeft(buttons[1]);
        expect(spy).to.be.calledOnce;
        expect(buttons[0].hasAttribute('focused')).to.be.true;
      });

      it('should move focus to first button on "home" keydown', () => {
        buttons[1].focus();
        const spy = sinon.spy(buttons[0], 'focus');
        home(buttons[1]);
        expect(spy).to.be.calledOnce;
        expect(buttons[0].hasAttribute('focused')).to.be.true;
      });

      it('should move focus to second button if first is disabled on "home" keydown', () => {
        menu.set('items.0.disabled', true);
        buttons[3].focus();
        const spy = sinon.spy(buttons[1], 'focus');
        home(buttons[3]);
        expect(spy).to.be.calledOnce;
        expect(buttons[1].hasAttribute('focused')).to.be.true;
      });

      it('should move focus to last button on "end" keydown', () => {
        buttons[0].focus();
        const spy = sinon.spy(buttons[3], 'focus');
        end(buttons[0]);
        expect(spy).to.be.calledOnce;
        expect(buttons[3].hasAttribute('focused')).to.be.true;
      });

      it('should move focus to the closest enabled button if last is disabled on "end" keydown', () => {
        menu.set('items.3.disabled', true);
        buttons[0].focus();
        const spy = sinon.spy(buttons[1], 'focus');
        end(buttons[0]);
        expect(spy).to.be.calledOnce;
        expect(buttons[1].hasAttribute('focused')).to.be.true;
      });

      it('should move focus to first button on "arrow-right", if last button has focus', () => {
        buttons[3].focus();
        const spy = sinon.spy(buttons[0], 'focus');
        arrowRight(buttons[3]);
        expect(spy).to.be.calledOnce;
        expect(buttons[0].hasAttribute('focused')).to.be.true;
      });

      it('should move focus to last button on "arrow-up", if first button has focus', () => {
        buttons[0].focus();
        const spy = sinon.spy(buttons[3], 'focus');
        arrowLeft(buttons[0]);
        expect(spy).to.be.calledOnce;
        expect(buttons[3].hasAttribute('focused')).to.be.true;
      });
    });

    describe('ellipsis button', () => {
      let menu, buttons, ellipsis;

      const assertHidden = elem => {
        const style = getComputedStyle(elem);
        expect(style.visibility).to.equal('hidden');
        expect(style.position).to.equal('absolute');
      };

      const assertVisible = elem => {
        const style = getComputedStyle(elem);
        expect(style.visibility).to.equal('visible');
        expect(style.position).to.not.equal('absolute');
      };

      beforeEach(done => {
        menu = fixture('default');

        menu.style.width = '250px';

        menu.items = [
          {text: 'Item 1'},
          {text: 'Item 2'},
          {text: 'Item 3'},
          {text: 'Item 4'},
        ];
        Polymer.RenderStatus.afterNextRender(menu, () => {
          buttons = menu._buttons;
          ellipsis = buttons[buttons.length - 1];
          done();
        });
      });

      it('should show ellipsis button and hide the buttons which do not fit', () => {
        assertHidden(buttons[2]);
        expect(buttons[2].disabled).to.be.true;
        assertHidden(buttons[3]);
        expect(buttons[3].disabled).to.be.true;
        expect(ellipsis.hasAttribute('hidden')).to.be.false;
      });

      it('should set items to ellipsis button for buttons which do not fit', () => {
        expect(ellipsis.item).to.be.an.object;
        expect(ellipsis.item.children).to.be.an.array;
        expect(ellipsis.item.children.length).to.equal(2);
        expect(ellipsis.item.children[0]).to.deep.equal(menu.items[2]);
        expect(ellipsis.item.children[1]).to.deep.equal(menu.items[3]);
      });

      it('should show buttons and update ellipsis items when width increased', done => {
        menu.style.width = '350px';
        menu.notifyResize();
        Polymer.RenderStatus.afterNextRender(menu, () => {
          assertVisible(buttons[1]);
          expect(buttons[1].disabled).to.not.be.true;
          expect(ellipsis.item.children.length).to.equal(1);
          expect(ellipsis.item.children[0]).to.deep.equal(menu.items[3]);
          done();
        });
      });

      it('should hide buttons and update ellipsis items when width decreased', done => {
        menu.style.width = '200px';
        menu.notifyResize();
        Polymer.RenderStatus.afterNextRender(menu, () => {
          assertHidden(buttons[2]);
          expect(buttons[2].disabled).to.be.true;
          expect(ellipsis.item.children.length).to.equal(3);
          expect(ellipsis.item.children[0]).to.deep.equal(menu.items[1]);
          expect(ellipsis.item.children[1]).to.deep.equal(menu.items[2]);
          expect(ellipsis.item.children[2]).to.deep.equal(menu.items[3]);
          done();
        });
      });

      it('should hide ellipsis button and reset its items when all buttons fit', done => {
        menu.style.width = 'auto';
        menu.notifyResize();
        Polymer.RenderStatus.afterNextRender(menu, () => {
          assertVisible(buttons[2]);
          expect(buttons[2].disabled).to.not.be.true;
          assertVisible(buttons[3]);
          expect(buttons[3].disabled).to.not.be.true;
          expect(ellipsis.hasAttribute('hidden')).to.be.true;
          expect(ellipsis.item.children.length).to.equal(0);
          done();
        });
      });
    });
  </script>
</body>
