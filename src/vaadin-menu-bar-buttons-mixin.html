<!--
@license
Copyright (c) 2019 Vaadin Ltd.
This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
-->

<link rel="import" href="../../polymer/lib/utils/async.html">
<link rel="import" href="../../polymer/lib/utils/debounce.html">
<link rel="import" href="../../polymer/lib/utils/render-status.html">
<link rel="import" href="../../iron-resizable-behavior/iron-resizable-behavior.html">

<script>
  /**
   * @namespace Vaadin
   */
  window.Vaadin = window.Vaadin || {};

  /**
   * @namespace Vaadin.MenuBar
   */
  window.Vaadin.MenuBar = window.Vaadin.MenuBar || {};

  /**
   * @polymerMixin
   */
  Vaadin.MenuBar.ButtonsMixin = superClass => class extends Polymer.mixinBehaviors(Polymer.IronResizableBehavior, superClass) {

    static get properties() {
      return {
        _hasOverflow: {
          type: Boolean,
          value: false
        }
      };
    }

    static get observers() {
      return [
        '_menuItemsChanged(items, items.splices)'
      ];
    }

    ready() {
      super.ready();

      this.addEventListener('keydown', e => this._onKeydown(e));
      this.addEventListener('focusin', e => this._onFocusin(e));
      this.addEventListener('iron-resize', e => this.__onResize());

      const container = this._container;

      container.addEventListener('click', e => this._onItemClick(e));
      container.addEventListener('keydown', e => e.keyCode === 40 && this._onItemClick(e));
    }

    get _buttons() {
      return Array.from(this.shadowRoot.querySelectorAll('[part$="button"]'));
    }

    get _container() {
      return this.shadowRoot.querySelector('[part="container"]');
    }

    _menuItemsChanged(items, splices) {
      if (items.length) {
        if (items !== this._oldItems) {
          this._oldItems = items;
          this.__renderButtons(items);
          this.__detectOverflow();
        }
      }
    }

    _onItemClick(e) {
      e.stopPropagation();
      const button = Array.from(e.composedPath()).filter(el => el.item)[0];
      if (button) {
        button.dispatchEvent(new CustomEvent('button-click', {
          detail: {item: button.item},
          bubbles: true,
          composed: true
        }));
      }
    }

    _onFocusin(event) {
      const target = this.shadowRoot.querySelector('[part$="button"][tabindex="0"]');
      if (target) {
        this._buttons.forEach(btn => {
          btn.setAttribute('tabindex', btn === target ? '0' : '-1');
        });
      }
    }

    _onKeydown(event) {
      const path = event.composedPath();
      const buttons = this._buttons;

      // only handle keydown event on menu bar buttons
      if (buttons.some(btn => path.indexOf(btn) > -1)) {
        // IE names for arrows do not include the Arrow prefix
        const key = event.key.replace(/^Arrow/, '');

        const currentIdx = buttons.indexOf(this.shadowRoot.activeElement);
        let idx;
        let increment;

        switch (key) {
          case 'Left':
            increment = -1;
            idx = currentIdx - 1;
            break;
          case 'Right':
            increment = 1;
            idx = currentIdx + 1;
            break;
          case 'Home':
            increment = 1;
            idx = 0;
            break;
          case 'End':
            increment = -1;
            idx = buttons.length - 1;
            break;
          default:
            // do nothing.
        }

        idx = this._getAvailableIndex(idx, increment, buttons);
        if (idx >= 0) {
          const btn = buttons[idx];
          btn.focus();
          btn.setAttribute('focus-ring', '');
          buttons.forEach(e => {
            e.setAttribute('tabindex', e === btn ? '0' : '-1');
          });
          event.preventDefault();
        }
      }
    }

    __detectOverflow() {
      const container = this._container;
      const buttons = this._buttons.slice(0);
      const ellipsis = buttons.pop();
      const containerWidth = container.offsetWidth;

      if (container.offsetWidth < container.scrollWidth) {
        this._hasOverflow = true;

        let i;
        for (i = buttons.length; i > 0; i--) {
          const btn = buttons[i - 1];
          if (getComputedStyle(btn).visibility === 'hidden') {
            continue;
          }

          const btnWidth = btn.offsetWidth;
          if ((btn.offsetLeft + btnWidth) < (containerWidth - ellipsis.offsetWidth)) {
            break;
          }

          btn.disabled = true;
          btn.style.visibility = 'hidden';
          btn.style.position = 'absolute';
        }

        ellipsis.item = {children: this.items.slice(i)};
      } else if (this._hasOverflow) {
        for (let i = 0; i < buttons.length; i++) {
          const btn = buttons[i];

          if (getComputedStyle(btn).visibility !== 'hidden') {
            continue;
          }

          const ellipsisLeft = ellipsis.offsetLeft;
          const btnWidth = btn.getBoundingClientRect().width;

          if ((ellipsisLeft + ellipsis.offsetWidth + btnWidth) < containerWidth) {
            btn.disabled = false;
            btn.style.visibility = '';
            btn.style.position = '';

            ellipsis.item = {children: this.items.slice(i + 1)};

            if (btn === buttons[buttons.length - 1]) {
              this._hasOverflow = false;
              ellipsis.item = {children: []};
            }
          } else {
            break;
          }
        }
      }
    }

    render() {
      this.__renderButtons(this.items);
    }

    __renderButtons(items = []) {
      const container = this._container;
      const ellipsis = container.querySelector('[part="ellipsis-button"]');

      while (container.children.length > 1) {
        container.removeChild(container.firstElementChild);
      }

      items.forEach(item => {
        let component;
        if (item.component instanceof HTMLElement) {
          component = item.component;
        } else {
          component = document.createElement(item.component || 'vaadin-menu-bar-button');
        }
        if (item.disabled) {
          component.disabled = true;
          component.setAttribute('tabindex', '-1');
        } else {
          component.setAttribute('tabindex', '0');
        }
        component.setAttribute('part', 'menu-bar-button');
        component.item = item;
        if (item.text) {
          component.textContent = item.text;
        }
        container.insertBefore(component, ellipsis);
      });
    }

    __onResize() {
      this.__debounceOverflow = Polymer.Debouncer.debounce(
        this.__debounceOverflow,
        Polymer.Async.animationFrame,
        this.__detectOverflow.bind(this)
      );
    }

    _getAvailableIndex(index, increment, buttons) {
      const totalItems = buttons.length;
      let idx = index;
      for (let i = 0; typeof idx === 'number' && i < totalItems; i++, idx += increment || 1) {
        if (idx < 0) {
          idx = totalItems - 1;
        } else if (idx >= totalItems) {
          idx = 0;
        }

        const btn = buttons[idx];
        if (!btn.disabled && !btn.hasAttribute('hidden')) {
          return idx;
        }
      }
      return -1;
    }
  };
</script>
