<!--
@license
Copyright (c) 2019 Vaadin Ltd.
This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
-->

<script>
  /**
   * @namespace Vaadin
   */
  window.Vaadin = window.Vaadin || {};

  /**
   * @namespace Vaadin.MenuBar
   */
  window.Vaadin.MenuBar = window.Vaadin.MenuBar || {};

  /**
   * @polymerMixin
   */
  Vaadin.MenuBar.KeyboardMixin = superClass => class extends superClass {

    ready() {
      super.ready();

      this.addEventListener('keydown', e => this._onKeydown(e));
      this.addEventListener('focusin', e => this._onFocusin(e));

      const container = this._container;

      container.addEventListener('click', e => {
        e.stopPropagation();
        const button = this._getButtonFromEvent(e);
        this._activateButton(button);
      });

      container.addEventListener('keydown', e => {
        const button = this._getButtonFromEvent(e);
        // ArrowDown
        if (e.keyCode === 40) {
          e.preventDefault();
          e.stopPropagation();
          if (button === this._expandedButton) {
            // Menu opened previously, focus first item
            this._focusFirstItem();
          } else {
            this._activateButton(button);
          }
        }
        // ArrowUp
        if (e.keyCode === 38) {
          e.preventDefault();
          e.stopPropagation();
          if (button === this._expandedButton) {
            // Menu opened previously, focus last item
            this._focusLastItem();
          } else {
            this._activateButton(button, {focusLast: true});
          }
        }
      });
    }

    get _buttons() {
      return Array.from(this.shadowRoot.querySelectorAll('[part$="button"]'));
    }

    get _container() {
      return this.shadowRoot.querySelector('[part="container"]');
    }

    _dispatchClick(button, options = {}) {
      button.dispatchEvent(new CustomEvent('button-click', {
        detail: {item: button.item, options},
        bubbles: true,
        composed: true
      }));
    }

    _activateButton(button, options = {}) {
      if (button) {
        this._dispatchClick(button, options);
      }
    }

    _focusButton(button) {
      button.focus();
      button.setAttribute('focus-ring', '');
      this._buttons.forEach(btn => {
        btn.setAttribute('tabindex', btn === button ? '0' : '-1');
      });
    }

    _getButtonFromEvent(e) {
      return Array.from(e.composedPath()).filter(el => el.item)[0];
    }

    _onFocusin(event) {
      const target = this.shadowRoot.querySelector('[part$="button"][tabindex="0"]');
      if (target) {
        this._buttons.forEach(btn => {
          btn.setAttribute('tabindex', btn === target ? '0' : '-1');
        });
      }
    }

    _onKeydown(event) {
      const path = event.composedPath();

      // only handle keydown event on menu bar buttons
      if (this._buttons.some(btn => path.indexOf(btn) > -1)) {
        let button = this._getButtonFromEvent(event);
        const expanded = button === this._expandedButton;
        if (expanded) {
          this._close(true);
        }
        this._navigateByKey(event);
        if (expanded) {
          button = this.shadowRoot.activeElement;
          const item = button.item;
          if (button && item && item.children) {
            this._dispatchClick(button, {keepFocus: true});
          }
        }
      }
    }

    _navigateByKey(event) {
      // IE names for arrows do not include the Arrow prefix
      const key = event.key.replace(/^Arrow/, '');
      const buttons = this._buttons;

      const currentIdx = buttons.indexOf(this.shadowRoot.activeElement);
      let idx;
      let increment;

      switch (key) {
        case 'Left':
          increment = -1;
          idx = currentIdx - 1;
          break;
        case 'Right':
          increment = 1;
          idx = currentIdx + 1;
          break;
        case 'Home':
          increment = 1;
          idx = 0;
          break;
        case 'End':
          increment = -1;
          idx = buttons.length - 1;
          break;
        default:
          // do nothing.
      }

      idx = this._getAvailableIndex(idx, increment, buttons);
      if (idx >= 0) {
        const btn = buttons[idx];
        this._focusButton(btn);
        event.preventDefault();
      }
    }

    _getAvailableIndex(index, increment, buttons) {
      const totalItems = buttons.length;
      let idx = index;
      for (let i = 0; typeof idx === 'number' && i < totalItems; i++, idx += increment || 1) {
        if (idx < 0) {
          idx = totalItems - 1;
        } else if (idx >= totalItems) {
          idx = 0;
        }

        const btn = buttons[idx];
        if (!btn.disabled && !btn.hasAttribute('hidden')) {
          return idx;
        }
      }
      return -1;
    }
  };
</script>
